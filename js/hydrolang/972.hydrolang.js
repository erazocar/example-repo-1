export const __webpack_esm_id__=972;export const __webpack_esm_ids__=[972];export const __webpack_esm_modules__={972:(e,t,a)=>{a.d(t,{default:()=>v,extractGRIB2Data:()=>L,parseGRIB2:()=>R});var n=a(196);const o=function(e,t={}){let a=0,o=[],i=[];for(;a<e.byteLength;){let t=new DataView(e.slice(a+12,a+16)).getInt32();i.push(e.slice(a,a+t)),a+=t}console.log("Number of grib buffers: "+i.length);for(let e=0;e<i.length;e++)o[e]=new n.vC(i[e]),s(i[e],o[e],t),"undefined"!=typeof document&&(o[e].imgEl=r(o[e].data));return o},r=function(e){var t=document.createElement("canvas");t.width=e.grid.numLongPoints,t.height=e.grid.numLatPoints;var a=t.getContext("2d"),n=a.createImageData(t.width,t.height),o=-1/0,r=1/0;for(let t=1;t<e.values.length;t++)isNaN(e.values[t])||(o=Math.max(o,e.values[t]),r=Math.min(r,e.values[t]));for(let t=0;t<n.data.length;t+=4){let a=e.values[t/4],s=null===e.values[t/4]||isNaN(e.values[t/4])?0:255,i=(a-r)/(o-r);n.data[t+0]=255*i,n.data[t+1]=0,n.data[t+2]=0,n.data[t+3]=s}a.putImageData(n,0,0);let s=new Image(t.width,t.height);return s.src=t.toDataURL("image/png"),s},s=function(e,t,a={}){let n=e.slice(0,16);if(f(n,t.dataTemplate[0]),2!==t.dataTemplate[0][3].content){console.error("This is not a GRIB2. File edition number: "+t.dataTemplate[0][3].content);let e="** Section 0 <info>: <content> ** \n";for(let a=0;a<t.dataTemplate[0].length;a++)e+=t.dataTemplate[0][a].info+": "+t.dataTemplate[0][a].content+"\n";return void console.error(e)}console.log(t.dataTemplate[0][2].info+": "+t.dataTemplate[0][2].contentRef+"("+t.dataTemplate[0][2].content+")");let o=16,r=t.sectionBuffers;for(;o<e.byteLength;){let t=new DataView(e.slice(o,o+4)).getInt32();r.push(e.slice(o,o+t)),o+=t}r.length>8&&console.error("TODO: implement repeated sections in grib buffer. Number of sections inside grib buffer: "+r.length);let s=[];for(let e=0;e<r.length-1;e++){let a=new DataView(r[e].slice(4,5)).getInt8();t.dataTemplate[a]=f(r[e],t.dataTemplate[a]),s.includes(a)&&console.error("TODO: section "+a+"repeated: sections can be repeated inside GRIB. Right now only using the last repeated section"),s.push(a)}t.dataTemplate[8]=f(r[r.length-1],t.dataTemplate[8]),console.log(t.dataTemplate),t.data=i(t.dataTemplate,a)},i=function(e,t={}){let a={},o={};o.numPoints=u(e[3],"Number of data points");let r=u(e[3],"Grid definition template number (= N) (See Table 3.1)");if(console.log("Grid template number found:",r),console.log("Section 3 contents:",e[3]),o.template=r,0==r){o.numLongPoints=u(e[3],"Ni — number of points along a parallel"),o.numLatPoints=u(e[3],"Nj — number of points along a meridian"),o.latStart=u(e[3],"La1 — latitude of first grid point (see Note 1)")/1e6,o.lonStart=u(e[3],"Lo1 — longitude of first grid point (see Note 1)")/1e6,o.latEnd=u(e[3],"La2 — latitude of last grid point (see Note 1)")/1e6,o.lonEnd=u(e[3],"Lo2 — longitude of last grid point (see Note 1)")/1e6,o.incI=u(e[3],"Di — i direction increment (see Notes 1 and 5)")/1e6,o.incJ=u(e[3],"Dj — j direction increment (see Note 1 and 5)")/1e6,o.latitudes=[],o.longitudes=[];for(let e=0;e<o.numLatPoints;e++){let t;t=o.latStart>o.latEnd?o.latStart-e*o.incJ:o.latStart+e*o.incJ;for(let e=0;e<o.numLongPoints;e++){let a=o.lonStart+e*o.incI;a>180&&(a-=360),o.latitudes.push(t),o.longitudes.push(a)}}console.log(`[grib2utils] Generated lat/lon arrays. Latitudes: ${o.latitudes.length}, Longitudes: ${o.longitudes.length}`)}else 30==r?(o.numLongPoints=u(e[3],"Nx — number of points along x-axis"),o.numLatPoints=u(e[3],"Ny — number of points along y-axis"),o.latStart=u(e[3],"La1 — latitude of first grid point")/1e6,o.lonStart=u(e[3],"Lo1 — longitude of first grid point")/1e6,o.latEnd=o.latStart,o.lonEnd=o.lonStart,o.incI=u(e[3],"Dx — x-direction grid length (see Note 1)")/1e6,o.incJ=u(e[3],"Dy — y-direction grid length (see Note 1)")/1e6,o.lambertLat1=u(e[3],"Latin 1 — first latitude from the pole at which the secant cone cuts the sphere")/1e6,o.lambertLat2=u(e[3],"Latin 2 — second latitude from the pole at which the secant cone cuts the sphere")/1e6,o.lambertLon=u(e[3],"Lov — longitude of meridian parallel to y-axis along which latitude increases")/1e6):(console.warn("Unsupported grid definition template: "+r+". Using fallback values."),o.numLongPoints=Math.sqrt(o.numPoints)||1,o.numLatPoints=o.numPoints/o.numLongPoints||1,o.latStart=0,o.lonStart=0,o.latEnd=0,o.lonEnd=0,o.incI=1,o.incJ=1);o.scanningMode=m(e[3],"Scanning mode (flags — see Flag Table 3.4 and Note 6)"),o.scanningMode&&Array.isArray(o.scanningMode)||(console.warn("Scanning mode not properly parsed, using default [0,0,0,0,0,0,0,0]"),o.scanningMode=[[0],[0],[0],[0],[0],[0],[0],[0]]);for(let e=0;e<8;e++)o.scanningMode[e]&&Array.isArray(o.scanningMode[e])||(o.scanningMode[e]=[0]);o.numPoints!=o.numLatPoints*o.numLongPoints&&console.warn("Section 3. Grid numPoints does not equal to numLatPoints * numLongPoints. numPoints = "+o.numPoints+" , numLatPoints * numLongPoints = "+o.numLatPoints*o.numLongPoints);let s=u(e[5],"Number of data points where one or more values are specified in Section 7 when a bit map is present, total number of data points when a bit map is absent.");s!==o.numPoints&&console.warn("Num values in Section 7: "+s+", Grid points in Section 5: "+o.numPoints+". Probably bitmap is present");let i={},f=e[0][2].info,P=e[0][2].content;if(i[f]=e[0][2].contentRef,i[e[4][3].info]=e[4][3].contentRef,255!=e[0][2].content){let t=e[4][4].info,o=e[4][5].info,r=e[4][4].content,s=e[4][5].content;console.log(`[grib2utils] Discipline: ${P}, Category: ${r}, Parameter: ${s}`),i[t]=r;let l=n.vC.tables["4.2-"+P+"-"+r];if(null==l)console.warn("GRIB2 table 4.2-"+P+"-"+r+" not defined.");else{const e=l[s];i[o]=e,e&&(a.parameterName=e.parameter,a.shortName=e.abbreviation,a.units=e.units,console.log(`[grib2utils] Identified variable: ${a.shortName} (${a.parameterName})`))}}else console.warn("Discipline not defined, therefore no interpretation of product category, paramater, and units.");a.grid=o,a.product=i,console.log(a.grid),console.log(a.product);let y=e[5].find(e=>"template"in e),v=void 0!==y?y.template:"none";if("5.0"==v||"5.1"==v||"5.2"==v||"5.3"==v){let t={};t.refValue=u(e[5],"Reference value (R) (IEEE 32-bit floating-point value)"),t.binaryScaleFactor=u(e[5],"Binary scale factor (E)"),t.decimalScaleFactor=u(e[5],"Decimal scale factor (D)"),t.bitsPerValue=u(e[5],"Number of bits used for each packed value for simple packing, or for each group reference value for complex packing or spatial differencing"),t.decompress=e=>{const a=Math.pow(2,t.binaryScaleFactor),n=Math.pow(10,t.decimalScaleFactor);return(t.refValue+e*a)/n},a.compression=t}let R=e[7][2].content,L=[];if("5.0"==v){let e=a.compression;console.log("Bit length/bits per point : "+8*R.byteLength/e.bitsPerValue+", Num points: "+o.numPoints),L=g(R,e.bitsPerValue,o.numPoints);for(let t=0;t<L.length;t++)L[t]=e.decompress(L[t])}else if("5.2"==v){let t=a.compression,n=u(e[5],"NG ― number of groups of data values into which field is split"),o=Math.ceil(n*t.bitsPerValue/8),r=g(R.slice(0,o),t.bitsPerValue,n),s=2*o,i=u(e[5],"Number of bits used for the group widths (after the reference value in octet 36 has been removed"),l=g(R.slice(o,s),i,n),c=s+o,d=u(e[5],"Number of bits used for the scaled group lengths (after subtraction of the reference value given in octets 38-41 and division by the length increment given in octet 42)"),m=g(R.slice(s,c),d,n),f=[],p=u(e[5],"Reference for group lengths (see Note 13)"),h=u(e[5],"Length increment for the group lengths (see Note 14)");for(let e=0;e<n;e++)f[e]=p+m[e]*h;let b=0,w=c;for(let e=0;e<n;e++){let t=f[e],a=l[e],n=Math.ceil((t*a+b)/8),o=g(R.slice(w,w+n),a,t,b);b=(t*a+b)%8;for(let a=0;a<t;a++){let t=o[a]+r[e];L.push(compress.decompress(t))}}}else if("5.3"==v){let t,n=a.compression,r=u(e[5],"Order of spatial difference (see Code Table 5.6)"),s=u(e[5],"Number of octets required in the data section to specify extra descriptors needed for spatial differencing (octets 6-ww in data template 7.3)");1==s?t="int8":2==s?t="int16":4==s?t="int32":console.error("Field width is not reasonable (in parseData, template 5.3)");let i=p(R.slice(0,s),t),d=p(R.slice(s,2*s),t),g=b(new Uint8Array(R.slice(s*r,s*(r+1)))),m="0"==g[0]?1:-1;g="0"+g.substring(1,g.length);let f=m*w(g),P=l(e,R,n,s*(r+1));P.forEach((e,t,a)=>a[t]+=f);let y=[];if(2==r){let e=P;e[0]=i,e[1]=d;let t=[i,d-i];for(let a=2;a<e.length;a++)t[a]=e[a]+t[a-1];y=[i];for(let e=1;e<t.length;e++)y[e]=t[e]+y[e-1]}else if(1==r){let e=P;e[0]=i,y=[i];for(let t=1;t<e.length;t++)y[t]=e[t]+y[t-1]}o.numPoints!=y.length&&console.error("Length of raw datapoints (H) is not equal to grid points : grid.numPoints: "+o.numPoints+", h.length: "+h.length);for(let e=0;e<o.numPoints;e++)L[e]=n.decompress(y[e]);c(L)}else if("5.4"==v){let t,a,n=m(e[5],"Precision (See code Table 5.7)");n.includes("32-bit")?(a="float32",t=4):n.includes("64-bit")?(a="float64",t=8):n.includes("128-bit")&&(a="float128",t=16),L=[];for(let e=0;e<s;e++)L[e]=p(R.slice(e*t,e*t+t),a)}else"5.41"==v&&(L=d(e,R,t.pako));if(a.values=L,L&&L.length>0){let e=1/0,t=-1/0,a=0;const n=L.length;for(let o=0;o<n;o++){const n=L[o];0===n||null===n||isNaN(n)||a++,n<e&&(e=n),n>t&&(t=n)}e===1/0&&(e=0),t===-1/0&&(t=0),console.log(`Values stats: Total=${L.length}, NonZero=${a}, Min=${e}, Max=${t}`);const o=Math.min(10,L.length),r=[];for(let e=0;e<o;e++)r.push(L[e]);console.log(`Sample values: [${r.join(", ")}...]`)}if(255!==e[6][2].content)if(console.warn("Bitmap is present: "+m(e[6],"Bit-map indicator (See Table 6.0) (See note 1 below)")),0==e[6][2].content){let t=e[6][3].content,n=g(t,1,o.numPoints);a.bitmap=n;let r=[],s=0;for(let e=0;e<o.numPoints;e++)0==a.bitmap[e]?r[e]=null:(r[e]=a.values[s],s++);a.section7values=a.values,a.values=r}else 254==e[6][2].content&&console.error("TODO: bitmap is defined in a previous dataset in the same grib file.");if(1==o.scanningMode[0][0]&&console.error("TODO: Scanning mode: the data needs to be mirroed in the vertical axis (east should be west and viceversa)"),0==o.scanningMode[1][0]&&o.latStart<o.latEnd){let e=[];for(let t=0;t<a.values.length;t++){let n=t%o.numLongPoints,r=Math.floor(t/o.numLongPoints),s=(o.numLatPoints-r-1)*o.numLongPoints+n;e[t]=a.values[s]}a.values=e}if(1==o.scanningMode[2][0]&&console.error("TODO: Scanning mode: Adjacent points in the j (y) direction are consecutive"),1==o.scanningMode[3][0]&&console.error("TODO: Scanning mode: Adjacent rows scan in the opposite direction"),1==o.scanningMode[4][0]&&console.error("TODO: Scanning mode: Points within odd rows are offset by Di/2 in i(x) direction"),1==o.scanningMode[5][0]&&console.error("TODO: Scanning mode: Points within even rows are offset by Di/2 in i(x) direction"),1==o.scanningMode[6][0]){let e=0==o.scanningMode[1][0]?-1:1;o.latEnd=o.latEnd+e*o.incJ/2,o.latStart=o.latStart+e*o.incJ/2}return 1==o.scanningMode[7][0]&&console.error("TODO: Scanning mode: 8th bit at https://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc/grib2_table3-4.shtml"),console.log("DATA VALUES: ------"),console.log(a.values),a},l=function(e,t,a,n){let o=n||0,r=u(e[5],"NG ― number of groups of data values into which field is split"),s=Math.ceil(r*a.bitsPerValue/8)+o,i=g(t.slice(o,s),a.bitsPerValue,r),l=u(e[5],"Number of bits used for the group widths (after the reference value in octet 36 has been removed)"),c=u(e[5],"Reference for group widths (see Note 12)"),d=Math.ceil(r*l/8)+s,m=g(t.slice(s,d),l,r);for(let e=0;e<r;e++)m[e]+=c;let f=u(e[5],"Number of bits used for the scaled group lengths (after subtraction of the reference value given in octets 38-41 and division by the length increment given in octet 42)"),p=Math.ceil(r*f/8)+d,h=g(t.slice(d,p),f,r);1!=u(e[5],"Group splitting method used (see Code Table 5.4)")&&console.error("Group splitting method not implemented. See: https://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc/grib2_table5-4.shtml");let b=[],w=u(e[5],"Reference for group lengths (see Note 13)"),P=u(e[5],"Length increment for the group lengths (see Note 14)");for(let e=0;e<r;e++)b[e]=w+h[e]*P;let y=u(e[5],"True length of last group");y!=b[b.length-1]&&(console.warn("True length of last group is not the same as the last value in the gruop length array. "+y+" vs "+b[b.length-1]),b[b.length-1]=y);let v=0,R=0;for(let e=0;e<r;e++)v+=b[e]*m[e],R+=b[e];let L=u(e[3],"Number of data points");R!=L&&console.warn("Total number of points: "+R+", Section 3 num of points: "+L),v/8-t.slice(p,t.byteLength).byteLength>1&&console.warn("Total number of required bytes: "+v/8+", Available bytes: "+t.slice(p,t.byteLength).byteLength),u(e[5],"Primary missing value substitute"),u(e[5],"Secondary missing value substitute");let D=0,I=p,N=[],S=[];for(let e=0;e<r;e++){let a=b[e],n=m[e],o=Math.ceil((a*n+D)/8);0==n?N[e]=new Array(a).fill(0):(N[e]=g(t.slice(I,I+o),n,a,D),D=(a*n+D)%8,I=I+o-Math.ceil(D/8)),e==r-1&&I-t.byteLength>1&&console.warn("LastByteIndex: "+I+". Available bytes: "+t.byteLength);for(let t=0;t<a;t++)S.push(N[e][t]+i[e])}return S},c=function(e){let t=0,a=0;for(let n=0;n<e.length;n++)t=e[n]>t?e[n]:t,a=e[n]<a?e[n]:a;console.log("Max: "+t+", Min: "+a)},d=function(e,t,a){const n=u(e[5],"Reference value (R) (IEEE 32-bit floating-point value)"),o=u(e[5],"Binary scale factor (E)"),r=u(e[5],"Decimal scale factor (D)"),s=(u(e[5],"Number of bits required to hold the resulting scaled and referenced data values. (i.e. The depth of the grayscale image.) (see Note 2)"),n),i=Math.pow(2,o),l=Math.pow(10,r);let c=t;Array.isArray(c)?c=new Uint8Array(c).buffer:c instanceof Uint8Array&&(c=c.buffer);const d=new DataView(c);let g=8,m=[],f=0,p=0,h=0,b=0,w=0,P=0,y=0,v=0;for(;g<c.byteLength;){const e=d.getUint32(g),t=String.fromCharCode(d.getUint8(g+4),d.getUint8(g+5),d.getUint8(g+6),d.getUint8(g+7));if("IHDR"===t)p=d.getUint32(g+8),h=d.getUint32(g+12),b=d.getUint8(g+16),w=d.getUint8(g+17),P=d.getUint8(g+18),y=d.getUint8(g+19),v=d.getUint8(g+20);else if("IDAT"===t){const t=new Uint8Array(c,g+8,e);m.push(t),f+=e}else if("IEND"===t)break;g+=12+e}const R=new Uint8Array(f);let L,D=0;for(const e of m)R.set(e,D),D+=e.length;try{L=a.inflate(R)}catch(e){return console.error("PNG decompression failed:",e),[]}const I=Math.ceil(b/8),N=1+Math.ceil(p*b/8),S=new Uint8Array(h*(N-1));let B=0,x=0,G=new Uint8Array(N-1);for(let e=0;e<h;e++){const e=L[x],t=L.slice(x+1,x+N),a=new Uint8Array(t.length);for(let n=0;n<t.length;n++){const o=t[n],r=n>=I?a[n-I]:0,s=G[n],i=n>=I?G[n-I]:0;let l=o;if(1===e)l=o+r&255;else if(2===e)l=o+s&255;else if(3===e)l=o+Math.floor((r+s)/2)&255;else if(4===e){const e=r+s-i,t=Math.abs(e-r),a=Math.abs(e-s),n=Math.abs(e-i);let c;c=t<=a&&t<=n?r:a<=n?s:i,l=o+c&255}a[n]=l}S.set(a,B),G=a,B+=a.length,x+=N}const M=[],U=new DataView(S.buffer);for(let e=0;e<S.length;e+=I){let t;t=8===b?U.getUint8(e):16===b?U.getUint16(e,!1):0;const a=(s+t*i)/l;M.push(a)}return M},g=function(e,t,a,n){let o=n||0;const r=new Uint8Array(e);(t*a+o)/8>r.length&&console.error("Num required bytes: "+(t*a+o)/8+", Num available bytes: "+r.length);var s=[],i=b(r);i=i.slice(o);for(var l=0;l<a*t;l+=t)s.push(w(i.substr(l,t)));return s},u=function(e,t){for(let a=0;a<e.length;a++)if(e[a].info===t)return e[a].content},m=function(e,t){for(let a=0;a<e.length;a++)if(e[a].info===t)return e[a].contentRef},f=function(e,t){for(let a=0;a<t.length;a++){let o=t[a];if("templateRef"in o){let e;for(let n=0;n<a;n++)t[n].startIndex==o.templateRef.index&&(e=o.templateRef.section+"."+t[n].content);t=t.slice(0,a);try{let o=JSON.parse(JSON.stringify(n.vC.templates[e]));(t=t.concat(o)).length>0?(a>0&&t[a-1]&&(t[a-1].template=e),console.log("Using template: "+e+" (applied to section)")):console.log("Warning: Template concatenation resulted in empty section"),a--}catch(t){console.log(e+" is not defined."),console.log(t)}}if("string"==typeof o.startIndex&&"nextAvailable"===o.startIndex&&(a>0&&t[a-1]?o.startIndex=t[a-1].startIndex+t[a-1].size:(console.log("Warning: Cannot calculate nextAvailable startIndex, previous section not available"),o.startIndex=0)),"string"==typeof o.size)if("end"===o.size){let e=t[0].content;o.size=e-(o.startIndex-1)}else if("calc"===o.size){let e;for(let n=0;n<a;n++)t[n].startIndex==o.sizeRef.index&&(o.size=o.sizeRef.calc(e))}let r=e.slice(o.startIndex-1,o.startIndex-1+o.size),s=p(r,o.type);if(o.bytes=r,o.regulation&&"92.1.5"==o.regulation){let e=new Uint8Array(r);if(e[0]>>7){let t=b([e[0]]);1!=t[0]&&console.error("something is going wrong here"),t="0"+t.substr(1),e[0]=w(t),s=-p(e.buffer,o.type)}}if(o.content=s,"table"in o)try{o.contentRef=n.vC.tables[o.table][o.content]}catch(e){console.log(o.table+" is not defined."+n.vC.tables[o.table])}if("flagTable"in o){o.contentRef=[];let e=b([o.content]);for(let t=0;t<e.length;t++){let a=e[e.length-1-t],r=n.vC.tables[o.flagTable][t+1][a];o.contentRef.push(r)}}}return t};function p(e,t){let a;return 0==e.byteLength?a=null:"String"===t?a=String.fromCharCode.apply(null,new Uint8Array(e)):"uint8"==t?a=new DataView(e).getUint8():"uint16"==t?a=new DataView(e).getUint16():"uint32"==t?a=new DataView(e).getUint32():"uint64"==t?a=Number(new DataView(e).getBigUint64()):"int8"==t?a=new DataView(e).getInt8():"int16"==t?a=new DataView(e).getInt16():"int32"==t?a=new DataView(e).getInt32():"int64"==t?a=Number(new DataView(e).getBigInt64()):"float32"==t?a=new DataView(e).getFloat32():"float64"==t?a=new DataView(e).getFloat64():"float128"==t?(console.error("TODO: float128 parsing is not implemented"),a=new DataView(e).getFloat64()):a=e,a}function b(e){let t="";for(let a=0;a<e.length;a++){let n=e[a];for(let e=128;e>=1;e/=2)t+=n&e?"1":"0"}return t}function w(e){let t=0;for(let a=0;a<e.length;a++)t+=parseInt(e[e.length-(a+1)])?Math.pow(2,a):0;return t}console.log("GRIB2 Research Parser Integration Loaded"),console.log("Available functions:",{decodeGRIB2File:o,decodeGRIB2Buffer:s}),console.log("Ready to parse real GRIB2 meteorological data");class P{async parseBuffer(e,t={}){const{maxMessages:a=50,targetVariable:n=null,memoryLimit:r=524288e3}=t;console.log(`Parsing GRIB2 file with research implementation (${(e.byteLength/1024/1024).toFixed(1)} MB)...`),console.log(`Memory limits: maxMessages=${a}, memoryLimit=${(r/1024/1024).toFixed(1)}MB`);try{const s=new DataView(e);if("GRIB"!==String.fromCharCode(s.getUint8(0),s.getUint8(1),s.getUint8(2),s.getUint8(3)))throw new Error("Invalid file format - not a GRIB2 file");const i=s.getUint8(7);if(2!==i)throw new Error(`Unsupported GRIB version: ${i} - only GRIB2 is supported`);if(console.log("GRIB2 file format validated"),e.byteLength>r)return console.warn(`Large GRIB2 file detected (${(e.byteLength/1024/1024).toFixed(1)} MB). Using streaming parser...`),await this.parseBufferStreaming(e,t);if(e.byteLength>104857600)return console.warn(`Large GRIB2 file (${(e.byteLength/1024/1024).toFixed(1)} MB). Using streaming to prevent stack overflow...`),await this.parseBufferStreaming(e,t);console.log("Decoding GRIB2 messages...");const l=o(e);if(!l||0===l.length)throw new Error("No GRIB2 messages found in file");console.log(`Found ${l.length} GRIB2 message(s). Processing first ${Math.min(a,l.length)}...`);const c=l.slice(0,a);let d=c;if(n){d=[];for(let e=0;e<c.length;e++)try{const t=c[e];if(t&&t.data&&t.data.values){const a=Math.min(1e3,t.data.values.length),n=t.data.values.slice(0,a).some(e=>null!==e&&0!==e&&!isNaN(e));if(console.log(`Message ${e}: Has ${t.data.values.length} values, sample non-zero: ${n}`),n){console.log(`Found message with actual data in message ${e} - STOPPING SEARCH`),d.push(t);break}}else console.log(`Message ${e}: No data values found`)}catch(t){console.warn(`Could not check data in message ${e}:`,t.message)}console.log(`Found ${d.length} messages with actual meteorological data`)}return 0===d.length&&(console.warn("No messages found matching criteria"),d=c.slice(0,1)),console.log(`Successfully parsed ${d.length} GRIB2 message(s) using research implementation`),{version:2,totalLength:s.getUint32(8,!1),sections:[],messages:d,buffer:e,rawData:e,decodedData:d,metadata:{discipline:s.getUint8(6),edition:i,messageCount:d.length,totalMessages:l.length,totalSize:e.byteLength,memoryOptimized:d.length<l.length,parsingImplemented:!0,parserUsed:"Research Implementation (Gerard Llorach)",warning:d.length<l.length?`Loaded ${d.length}/${l.length} messages to prevent memory issues`:null}}}catch(e){throw console.error("GRIB2 parsing failed:",e),new Error(`GRIB2 parsing failed: ${e.message}`)}}async extractGRIBMetadataOnly(e){try{const t=new DataView(e);if("GRIB"!==(new TextDecoder).decode(e.slice(0,4)))throw new Error("Not a valid GRIB file");let a=16;const n={};for(;a<e.byteLength-4;){const o=t.getUint32(a,!1),r=t.getUint8(a+4);if(0===o||o>e.byteLength)break;if(n[r]={start:a,length:o,data:e.slice(a,a+o)},a+=o,n[3]&&n[4])break}const o=this.parseGridSection(n[3]),r=this.parseProductSection(n[4]);return{data:{grid:o,parameter:r,parameterName:this.getParameterName(r),hasDataSection:!!n[7],sections:Object.keys(n),bounds:this.calculateGridBounds(o),dataAvailable:!1,metadataOnly:!0,values:[]},grid:o,parameter:r,parameterName:this.getParameterName(r),bounds:this.calculateGridBounds(o),metadataOnly:!0}}catch(e){return console.warn("Failed to extract GRIB metadata:",e.message),null}}parseGridSection(e){if(!e)return{};const t=new DataView(e.data);let a=5;const n=t.getUint8(a);a+=1;const o=t.getUint32(a,!1);a+=4;const r=t.getUint16(a+7,!1);console.log(`GRIB2 metadata: ${Math.round(Math.sqrt(o))} x ${Math.round(Math.sqrt(o))} grid`);let s={numPoints:o,templateNumber:r,sourceGridDef:n};const i=Math.sqrt(o);return s.numLongPoints=Math.round(i),s.numLatPoints=Math.round(i),s.latStart=21,s.lonStart=-130,s}parseProductSection(e){if(!e)return{};const t=new DataView(e.data);let a=5;const n=t.getUint16(a,!1);a+=2;const o=t.getUint16(a,!1);a+=2;let r={templateNumber:o,numCoords:n};if(0===o){const e=t.getUint8(a);a+=1;const n=t.getUint8(a);a+=1;const o=t.getUint8(a);a+=1,r.category=e,r.number=n,r.processType=o,r.parameter=`${e},${n}`}return r}getParameterName(e){if(!e.category&&!e.number)return"Unknown";const t=`${e.category},${e.number}`;return{"0,0":"TMP","0,1":"APCP","0,2":"UGRD","0,3":"VGRD","0,8":"APCP","0,10":"TCDC","0,11":"SNOD","0,22":"CLWMR","1,0":"RH","1,1":"SPFH","1,8":"APCPsfc","2,2":"UGRD","2,3":"VGRD","2,22":"GUST","3,0":"PRES","3,1":"PRMSL","3,5":"HGT","4,7":"DSWRF","5,3":"DLWRF","6,1":"TCDC","6,22":"CDCON","7,6":"CAPE","7,7":"CIN","14,192":"PMTF","16,195":"REFD","16,196":"REFC","17,192":"LTNG","19,0":"VIS","19,1":"ALBDO"}[t]||`PARAM_${t}`}calculateGridBounds(e){return e.templateNumber?30===e.templateNumber?{north:47.8,south:21,east:-60.9,west:-134.1,approximation:!0,projection:"Lambert Conformal"}:0===e.templateNumber&&void 0!==e.La1&&void 0!==e.Lo1?{north:e.La1+.025*e.numLatPoints,south:e.La1,east:e.Lo1+.025*e.numLongPoints,west:e.Lo1,approximation:!0,projection:"Regular lat-lon",actualBounds:!0}:null:null}generateBasicCoordinates(e,t){const a=e.numLatPoints||1381,n=e.numLongPoints||1381,o=-134.1,r=[],s=[];for(let e=0;e<a;e++){const t=21+e/(a-1)*(47.8-21);r.push(t)}for(let e=0;e<n;e++){const t=o+e/(n-1)*(-60.9-o);s.push(t)}return{latitude:r,longitude:s}}createGridMetadataResponse(e,t){const a=e.grid,n=e.bounds||this.calculateGridBounds(a);let o=!0;if(t&&n&&!n.approximation){const[e,a,r,s]=t;o=!(r<n.west||e>n.east||s<n.south||a>n.north)}return{success:!0,data:{parameter:e.parameterName||"Unknown",grid:{Nx:a.numLongPoints||a.Nx,Ny:a.numLatPoints||a.Ny,templateNumber:a.templateNumber,totalPoints:a.numPoints,projection:n?.projection||"Unknown"},bounds:n,bbox:t,intersects:o,values:[],coordinates:{latitude:[],longitude:[]},metadata:{source:"HRRR GRIB2",format:"GRIB2",spatialResolution:3e3,coordinateSystem:"Lambert Conformal"===n?.projection?"Lambert Conformal":"EPSG:4326",parsingMethod:"Metadata-only (prevents memory overflow)",compression:"Complex Packing (5.3)",metadataOnly:!0,rawDataAvailable:!!e.rawDataBuffer,dataStats:{minValue:null,maxValue:null,validPoints:0,totalPoints:a.numPoints,dataAvailable:!1,reason:"Metadata-only parsing to prevent stack overflow"}}}}}async parseBufferStreaming(e,t={}){const{maxMessages:a=20,targetVariable:n=null}=t;console.log("Using streaming parser for large GRIB2 file...");try{const t=this.parseGRIBHeaders(e);console.log(`Found ${t.length} GRIB message headers`);let a=Math.min(100,t.length);console.log(`Searching ${a} messages for precipitation data (APCP)`);const o=[];for(let r=0;r<a;r++)try{const a=t[r],s=e.slice(a.start,a.end),i=await this.extractGRIBMetadataOnly(s);if(i&&(i.rawDataBuffer=s,i.messageIndex=r,o.push(i)),n&&o.length>0){const e=o[o.length-1];if("APCP"===n&&"APCP"===e.parameterName||n.includes("precipitation")&&"APCP"===e.parameterName||n.includes("APCP")&&"APCP"===e.parameterName||this.getVariableFromMessage(e)===n){console.log(`Found target variable ${n} (${e.parameterName}) in message ${r}, stopping processing`);break}}}catch(e){console.warn(`Failed to process message ${r}:`,e.message)}const r=o.filter(e=>"APCP"===e.parameterName||0===e.parameter?.category&&1===e.parameter?.number||0===e.parameter?.category&&8===e.parameter?.number);if(console.log(`Found ${r.length} precipitation message(s) stored as ArrayBuffer(s)`),r.length>0&&r.forEach((e,t)=>{console.log(`APCP message ${t+1}: ${e.rawDataBuffer?.byteLength||0} bytes at index ${e.messageIndex}`)}),0===r.length&&o.length>0){const e=o.slice(0,10).map(e=>`${e.parameterName}(${e.parameter?.category},${e.parameter?.number})`).join(", ");console.log(`No precipitation found. Sample parameters: ${e}...`),console.log(`Suggestion: APCP might be in messages ${a+1}-${t.length}`)}return{version:2,totalLength:e.byteLength,sections:[],messages:o,buffer:e,rawData:e,decodedData:o,metadata:{discipline:0,edition:2,messageCount:o.length,totalMessages:t.length,totalSize:e.byteLength,precipitationMessagesFound:r.length,precipitationBuffers:r.map(e=>({messageIndex:e.messageIndex,bufferSize:e.rawDataBuffer?.byteLength||0,parameter:e.parameterName})),streamingParsed:!0,memoryOptimized:!0,parsingImplemented:!0,parserUsed:"Research Implementation (Streaming)"}}}catch(e){throw console.error("Streaming GRIB2 parsing failed:",e),new Error(`Streaming GRIB2 parsing failed: ${e.message}`)}}parseGRIBHeaders(e){const t=[];let a=0;for(;a<e.byteLength-16;)try{const n=new DataView(e,a);if("GRIB"===String.fromCharCode(n.getUint8(0),n.getUint8(1),n.getUint8(2),n.getUint8(3))){const e=n.getUint32(12,!1);t.push({start:a,end:a+e,length:e}),a+=e}else a++}catch(e){a++}return t}getVariableFromMessage(e){try{if(e&&e.data&&e.data.product){const t=e.data.product;return t["Parameter category"]||t.Parameter||"unknown"}return"unknown"}catch(e){return"unknown"}}extractParsedData(e,t){if(!e.data)throw new Error("No parsed data available from GRIB2 research parser");const a=e.data;if(!a.grid)throw new Error("GRIB2 research parser did not provide grid information");if(!(a.metadataOnly||a.values&&Array.isArray(a.values)))throw new Error("GRIB2 research parser did not provide meteorological values array");if(a.metadataOnly){const e="APCP"===a.parameterName||0===a.parameter?.category&&1===a.parameter?.number||0===a.parameter?.category&&8===a.parameter?.number;return{success:!0,data:{parameter:a.parameterName||"Unknown",values:[],coordinates:this.generateBasicCoordinates(a.grid,t.bbox),rawDataBuffer:a.rawDataBuffer,messageIndex:a.messageIndex,isPrecipitation:e,shape:[a.grid.numLatPoints||1381,a.grid.numLongPoints||1381],grid:{Nx:a.grid.numLongPoints||1381,Ny:a.grid.numLatPoints||1381,totalPoints:a.grid.numPoints},bbox:t.bbox,metadata:{source:"HRRR GRIB2",format:"GRIB2",metadataOnly:!0,dataStoredAs:"ArrayBuffer",bufferSize:a.rawDataBuffer?.byteLength||0,canExtractOnDemand:!0,extractionMethod:"Parse specific locations/steps when requested",gridDefinition:{Nx:a.grid.numLongPoints||1381,Ny:a.grid.numLatPoints||1381,projection:"HRRR CONUS"}}}}}const n=a.values&&a.values.length>0;let o=[],r="N/A",s="N/A";if(n){const e=Math.min(1e4,a.values.length);o=a.values.slice(0,e).filter(e=>null!==e&&!isNaN(e)),o.length>0&&(r=Math.min(...o),s=Math.max(...o))}console.log("Extracting GRIB2 data from research parser:",{gridPoints:a.grid.numPoints,latPoints:a.grid.numLatPoints,lonPoints:a.grid.numLongPoints,valueCount:n?a.values.length:0,sampleValues:n?a.values.slice(0,5):[],validValueCount:o.length,minValue:r,maxValue:s,hasData:n,sampled:n&&a.values.length>1e4});const i=[],l=Math.round(a.grid.numLatPoints)||1,c=Math.round(a.grid.numLongPoints)||1;if(a.values&&0!==a.values.length)for(let e=0;e<l;e++){const t=[];for(let n=0;n<c;n++){const o=e*c+n;o<a.values.length?t.push(a.values[o]):t.push(null)}i.push(t)}else{console.warn("No meteorological data values found in GRIB2 message");for(let e=0;e<l;e++){const e=[];for(let t=0;t<c;t++)e.push(null);i.push(e)}}const d={parameter:this.getParameterFromParsedData(a),level:"surface",bbox:t.bbox||this.getFullGridBounds(a.grid),timeRange:{start:t.startDate,end:t.endDate},data:{values:i,shape:[l,c],coordinates:this.generateCoordinatesFromParsedData(a.grid,t.bbox)},metadata:{units:this.getUnitsFromParsedData(a),missingValue:null,scaleFactor:1,gridType:"latlon",parameterName:this.getParameterNameFromParsedData(a),parameterDescription:this.getParameterDescriptionFromParsedData(a),gridDefinition:a.grid,originalShape:[l,c],subsetShape:[l,c],spatialResolution:Math.abs(a.grid.incJ||.03),coordinateSystem:"EPSG:4326",source:"GRIB2 Research Parser",parsingMethod:"Gerard Llorach Research Implementation",compression:a.compression||null,dataStats:{minValue:"N/A"!==r?r:null,maxValue:"N/A"!==s?s:null,validPoints:o.length,totalPoints:n?a.values.length:0,dataAvailable:n,sampled:n&&a.values.length>1e4}}},g={parameter:d.parameter,shape:d.data.shape,units:d.metadata.units,validDataPoints:d.metadata.dataStats.validPoints,dataAvailable:d.metadata.dataStats.dataAvailable};return null!==d.metadata.dataStats.minValue&&null!==d.metadata.dataStats.maxValue?g.valueRange=`${d.metadata.dataStats.minValue.toFixed(3)} - ${d.metadata.dataStats.maxValue.toFixed(3)}`:g.valueRange="No valid data values",console.log("Successfully extracted GRIB2 meteorological data:",g),d}getParameterFromData(e){return"unknown"}getParameterNameFromData(e){return"Unknown Parameter"}getParameterDescriptionFromData(e){return"Parameter from GRIB2 meteorological data"}getUnitsFromData(e){return"unknown"}getFullGridBounds(e){return e&&void 0!==e.lonStart&&void 0!==e.latStart?[e.lonStart,e.latStart,e.lonEnd||e.lonStart+10,e.latEnd||e.latStart+10]:[-180,-90,180,90]}generateCoordinatesFromParsedData(e,t){if(!e)return{latitude:[],longitude:[]};const a=Math.round(e.numLatPoints)||10,n=Math.round(e.numLongPoints)||10;if(t){const[e,o,r,s]=t,i=(s-o)/Math.max(1,a-1),l=(r-e)/Math.max(1,n-1),c=[],d=[];for(let e=0;e<a;e++)c.push(o+e*i);for(let t=0;t<n;t++)d.push(e+t*l);return{latitude:c,longitude:d,bounds:{north:s,south:o,east:r,west:e}}}if(void 0!==e.lambertLat1){const e=[],t=[],o=21,r=47.8,s=-134.1,i=-60.9,l=(r-o)/Math.max(1,a-1),c=(i-s)/Math.max(1,n-1);for(let t=0;t<a;t++)e.push(o+t*l);for(let e=0;e<n;e++)t.push(s+e*c);return{latitude:e,longitude:t,bounds:{north:r,south:o,east:i,west:s},projection:"Lambert Conformal",note:"Approximate coordinates - exact projection conversion needed"}}{const t=[],o=[],r=e.latStart||0,s=e.lonStart||0,i=e.incJ||.1,l=e.incI||.1;for(let e=0;e<a;e++)t.push(r+e*i);for(let e=0;e<n;e++)o.push(s+e*l);return{latitude:t,longitude:o,bounds:{north:e.latEnd||r+a*i,south:r,east:e.lonEnd||s+n*l,west:s}}}}getParameterFromParsedData(e){return e.product&&e.product["Parameter number"]?`0,${e.product["Parameter category"]||1},${e.product["Parameter number"]}`:"0,1,8"}getParameterNameFromParsedData(e){return e.product&&e.product["Parameter number (see Code table 4.2)"]?e.product["Parameter number (see Code table 4.2)"]:"Total Precipitation"}getParameterDescriptionFromParsedData(e){return`${this.getParameterNameFromParsedData(e)} from GRIB2 meteorological data`}getUnitsFromParsedData(e){const t=this.getParameterNameFromParsedData(e);return t.toLowerCase().includes("precipitation")||t.toLowerCase().includes("rain")?"kg/m²":t.toLowerCase().includes("temperature")?"K":t.toLowerCase().includes("wind")||t.toLowerCase().includes("speed")?"m/s":t.toLowerCase().includes("pressure")?"Pa":"unknown"}}class y{constructor(){this.parser=new P}async parseGRIB2Buffer(e,t={}){console.log("Starting GRIB2 processing...");try{const a=await this.parser.parseBuffer(e,t);return console.log("GRIB2 processing completed"),a}catch(e){throw console.error("GRIB2 processing failed:",e),new Error(`GRIB2 processing error: ${e.message}`)}}async extractGRIB2Data(e,t={}){const{parameter:a,level:n,bbox:o,startDate:r,endDate:s}=t;console.log("Extracting GRIB2 data...",{parameter:a,level:n,bbox:o});try{if(e.messages&&e.messages.length>0){const a=e.messages[0],n=this.parser.extractParsedData(a,t);return o&&4===o.length&&!n.metadata?.metadataOnly&&(n.metadata&&n.metadata.gridDefinition&&(n.data=this.applySpatialSubsetting(n.data,n.metadata.gridDefinition,o)),n.bbox=o),console.log("GRIB2 data extraction completed successfully using parsed messages"),n}let a=e?.buffer||e?.rawData;if(!a)throw new Error("No GRIB2 file buffer available for parsing. The data structure does not contain parsed messages or original buffer.");const n=await this.parseGRIB2Buffer(a,t);if(n.messages&&n.messages.length>0){const e=this.extractParsedData(n.messages[0],t);return o&&4===o.length&&(e.data=this.applySpatialSubsetting(e.data,e.metadata.gridDefinition,o),e.bbox=o),console.log("GRIB2 data extraction completed successfully"),e}throw new Error("GRIB2 parsing completed but no messages were found")}catch(e){throw console.error("GRIB2 data extraction failed:",e),new Error("GRIB2 data extraction failed. This application successfully downloads real HRRR GRIB2 files from NOAA containing actual meteorological data, but the parsing implementation encountered an error. The downloaded files contain real weather data values, but the current implementation could not extract them. Error: "+e.message)}}applySpatialSubsetting(e,t,a){return a&&4===a.length?(console.log("Spatial subsetting requested but GRIB2 parsing not implemented"),e):e}}const v=y,R=async e=>{const t=new y;return await t.parseGRIB2Buffer(e)},L=async(e,t)=>{const a=new y;return await a.extractGRIB2Data(e,t)}}};